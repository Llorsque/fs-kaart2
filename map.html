<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Schoolschaatsen â€“ Kaart</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
</head>
<body onload="loadMode()">
  <div class="topbar">
    <div class="controls-row">
      <button class="btn btn-small" onclick="toggleMode()">ğŸ“± / ğŸ–¥ï¸</button>
      <button id="exportBtn" class="btn btn-small btn-ghost">â¬‡ï¸ Exporteer gefilterd</button>
      <span class="spacer"></span>
      <a class="btn btn-small btn-ghost" href="index.html">ğŸ </a>
    </div>
  </div>

  <div class="container">
    <aside class="sidebar">
      <header class="card">
        <h1>ğŸ—ºï¸ Kaart & live aantallen</h1>
        <p class="sub">Deelname-jaren samengevoegd. Aantal kinderen met schuif (min/max), gekoppeld aan gekozen jaren.</p>
      </header>

      <section class="card">
        <h3 style="margin-top:0">Filters</h3>
        <div id="filters" class="filter-group"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="applyBtn" class="btn btn-small">Filters toepassen</button>
          <button id="resetBtn" class="btn btn-small btn-ghost">Reset</button>
        </div>
      </section>

      <section class="card">
        <h3 style="margin-top:0">Live aantallen</h3>
        <div class="kpis">
          <div class="kpi"><div class="label">Totaal (gefilterd)</div><div id="k_total" class="n">â€“</div></div>
          <div class="kpi"><div class="label">Met lat/lon</div><div id="k_geo" class="n">â€“</div></div>
        </div>
      </section>

      <section class="card table">
        <table id="previewTable"><thead></thead><tbody></tbody></table>
      </section>
    </aside>

    <main class="card" style="padding:0">
      <div id="map"></div>
    </main>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script src="utils.js"></script>
  <script>
    const DATA_URL = 'data/schools.json';
    let allRows = [], filtered = [];
    let filterGetters = {};
    let seasonFilterGetter = null;
    let seasonMap = {}; // label -> 'DEELNAME ...' column
    let countMap = {};  // label -> 'AANTAL KINDEREN ...' column
    let rangeGetter = null;

    const EXCLUDE_FILTERS = ['naam school','naam','adres','huisnummer','huisnummer-toevoeging','postcode','plaatsnaam correspondentieadres'];

    const map = L.map('map').setView([52.2,5.3],7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19}).addTo(map);
    const markerGroup = L.markerClusterGroup({ spiderfyOnMaxZoom:true }).addTo(map);

    function escapeHtml(s){ return String(s??'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
    function buildPopup(row){
      const titleCandidates = ['NAAM SCHOOL','naam','School','school'];
      const titleKey = titleCandidates.find(k=>k in row) || null;
      const title = titleKey ? row[titleKey] : 'Onbekend';
      const pairs = Object.entries(row).map(([k,v])=>`<tr><th style="text-align:left;padding-right:8px">${escapeHtml(k)}</th><td>${escapeHtml(v)}</td></tr>`).join('');
      return `<div><strong>${escapeHtml(title)}</strong><br/><table>${pairs}</table></div>`;
    }

    function renderTable(rows){
      const thead = document.querySelector('#previewTable thead');
      const tbody = document.querySelector('#previewTable tbody');
      thead.innerHTML=''; tbody.innerHTML='';
      if(!rows.length) return;
      const cols = Object.keys(rows[0]);
      const tr = document.createElement('tr'); cols.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; tr.appendChild(th); }); thead.appendChild(tr);
      rows.slice(0,80).forEach(r=>{
        const tr = document.createElement('tr');
        cols.forEach(c=>{ const td=document.createElement('td'); td.textContent = r[c] ?? ''; tr.appendChild(td); });
        tbody.appendChild(tr);
      });
    }

    function findLat(row){
      for(const k of Object.keys(row)){
        const key = k.toLowerCase();
        if(key==='lat' || key==='latitude' || key==='breedtegraad') return parseFloat(String(row[k]).replace(',','.'));
      }
      return NaN;
    }
    function findLon(row){
      for(const k of Object.keys(row)){
        const key = k.toLowerCase();
        if(key==='lon' || key==='long' || key==='longitude' || key==='lengtegraad') return parseFloat(String(row[k]).replace(',','.'));
      }
      return NaN;
    }

    function renderMap(rows){
      markerGroup.clearLayers();
      const markers = [];
      for(const r of rows){
        const lat = findLat(r);
        const lon = findLon(r);
        if(!isFinite(lat) || !isFinite(lon)) continue;
        const m = L.marker([lat, lon]);
        m.bindPopup(buildPopup(r));
        markerGroup.addLayer(m);
        markers.push(m);
      }
      if(markers.length){
        const grp = L.featureGroup(markers);
        map.fitBounds(grp.getBounds().pad(0.12));
      }
      document.getElementById('k_geo').textContent = markers.length;
    }

    function renderKPIs(rows){
      document.getElementById('k_total').textContent = rows.length;
    }

    function normalize(val){ return String(val??'').trim().toLowerCase(); }
    function boolFrom(val){ return ['ja','waar','true','1','x','y'].includes(normalize(val)); }
    function toInt(val){ const s = String(val??'').replace(/[^0-9-]/g,'').trim(); if(!s) return null; const n = parseInt(s,10); return isFinite(n)? n : null; }

    function applyFilters(){
      const active = {};
      for(const [key, getter] of Object.entries(filterGetters)){
        active[key] = new Set(Array.from(getter()));
      }
      const selectedSeasons = seasonFilterGetter ? new Set(Array.from(seasonFilterGetter())) : new Set();
      const range = rangeGetter ? rangeGetter() : null;

      filtered = allRows.filter(r=>{
        // 1) Generic filters (AND)
        for(const [k,set] of Object.entries(active)){
          if(set.size===0) continue;
          const val = (r[k]??'').toString();
          if(!set.has(val)) return false;
        }

        // 2) Season filter (OR on selected seasons with DEELNAME JA)
        if(selectedSeasons.size>0){
          let ok = false;
          for(const label of selectedSeasons){
            const col = seasonMap[label];
            if(col && boolFrom(r[col])){ ok = true; break; }
          }
          if(!ok) return false;
        }

        // 3) Range on AANTAL KINDEREN for the same selected seasons
        if(range){
          const [minV,maxV] = range;
          let match = false;
          const labels = selectedSeasons.size>0 ? Array.from(selectedSeasons) : Object.keys(countMap);
          for(const label of labels){
            const countCol = countMap[label];
            if(!countCol) continue;
            const n = toInt(r[countCol]);
            if(n!==null && n>=minV && n<=maxV){ match = true; break; }
          }
          if(!match) return false;
        }

        return true;
      });
      renderKPIs(filtered);
      renderMap(filtered);
      renderTable(filtered);
    }

    function detectSeasonAndCount(sample){
      const sMap = {}; // label -> deelname col
      const cMap = {}; // label -> aantal col
      for(const col of Object.keys(sample)){
        const lower = col.toLowerCase();
        const m = col.match(/(20\d{2})\s*[\/-]\s*(20\d{2})/);
        if(!m) continue;
        const label = `${m[1]}/${m[2]}`;
        if(lower.includes('deelname')) sMap[label] = col;
        if(lower.includes('aantal') && lower.includes('kind')) cMap[label] = col;
      }
      return [sMap, cMap];
    }

    function buildFilters(rows){
      const container = document.getElementById('filters');
      container.innerHTML='';
      filterGetters = {};
      seasonFilterGetter = null;
      rangeGetter = null;
      seasonMap = {}; countMap = {};

      if(!rows.length) return;
      const sample = rows[0];

      // Detect season & count columns
      [seasonMap, countMap] = detectSeasonAndCount(sample);

      // 0) Combined Deelname (jaren)
      if(Object.keys(seasonMap).length){
        const getter = buildMultiSelect(container, 'Deelname (jaren)', Object.keys(seasonMap));
        if(getter) seasonFilterGetter = getter;
      }

      // 1) Aantal kinderen (range) â€” over geselecteerde jaren; bij geen selectie over alle jaren
      // determine global min/max over all count columns
      let minVal = Infinity, maxVal = -Infinity;
      rows.forEach(r=>{
        Object.values(countMap).forEach(col=>{
          const n = toInt(r[col]);
          if(n!==null){ if(n<minVal) minVal=n; if(n>maxVal) maxVal=n; }
        });
      });
      if(minVal===Infinity){ minVal=0; maxVal=0; } // fallback
      rangeGetter = buildRange(container, 'Aantal kinderen (min/max)', minVal, maxVal);

      // 2) Generic filters for other columns (exclude specified ones and coords and the raw deelname/aantal columns we already handle)
      const exclude = new Set(['lat','lon','latitude','longitude','breedtegraad','lengtegraad']);
      const rawSeasonCols = new Set([...Object.values(seasonMap).map(v=>v.toLowerCase()), ...Object.values(countMap).map(v=>v.toLowerCase())]);
      const cols = Object.keys(sample).filter(k=>{
        const lower = k.toLowerCase();
        if(exclude.has(lower)) return false;
        if(rawSeasonCols.has(lower)) return false;
        // remove user-requested filters
        if(EXCLUDE_FILTERS.some(x => lower.includes(x))) return false;
        return true;
      });
      cols.forEach(col=>{
        const values = rows.map(r=> r[col]);
        const getter = buildMultiSelect(container, col, values);
        if(getter) filterGetters[col] = getter;
      });
    }

    async function loadData(){
      const res = await fetch(DATA_URL);
      const data = await res.json();
      allRows = data;
      filtered = allRows.slice();
      buildFilters(allRows);
      renderKPIs(filtered);
      renderMap(filtered);
      renderTable(filtered);
    }

    document.getElementById('applyBtn').addEventListener('click', applyFilters);
    document.getElementById('resetBtn').addEventListener('click', resetFilters);
    document.getElementById('exportBtn').addEventListener('click', ()=> exportCSV(filtered, 'filtered_export.csv'));

    loadData();
  </script>
</body>
</html>
